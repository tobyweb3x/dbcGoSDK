// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package dynamic_vault

import (
	"encoding/json"
	"errors"
	"fmt"
	ag_jsonrpc "github.com/gagliardetto/solana-go/rpc/jsonrpc"
)

var (
	_ *json.Encoder        = nil
	_ *ag_jsonrpc.RPCError = nil
	_ fmt.Formatter        = nil
	_                      = errors.ErrUnsupported
)
var (
	ErrVaultIsDisabled = &customErrorDef{
		code: 6000,
		msg:  "Vault is disabled",
		name: "VaultIsDisabled",
	}
	ErrExceededSlippage = &customErrorDef{
		code: 6001,
		msg:  "Exceeded slippage tolerance",
		name: "ExceededSlippage",
	}
	ErrStrategyIsNotExisted = &customErrorDef{
		code: 6002,
		msg:  "Strategy is not existed",
		name: "StrategyIsNotExisted",
	}
	ErrUnAuthorized = &customErrorDef{
		code: 6003,
		msg:  "UnAuthorized",
		name: "UnAuthorized",
	}
	ErrMathOverflow = &customErrorDef{
		code: 6004,
		msg:  "Math operation overflow",
		name: "MathOverflow",
	}
	ErrProtocolIsNotSupported = &customErrorDef{
		code: 6005,
		msg:  "Protocol is not supported",
		name: "ProtocolIsNotSupported",
	}
	ErrUnMatchReserve = &customErrorDef{
		code: 6006,
		msg:  "Reserve does not support token mint",
		name: "UnMatchReserve",
	}
	ErrInvalidLockedProfitDegradation = &customErrorDef{
		code: 6007,
		msg:  "lockedProfitDegradation is invalid",
		name: "InvalidLockedProfitDegradation",
	}
	ErrMaxStrategyReached = &customErrorDef{
		code: 6008,
		msg:  "Maximum number of strategies have been reached",
		name: "MaxStrategyReached",
	}
	ErrStrategyExisted = &customErrorDef{
		code: 6009,
		msg:  "Strategy existed",
		name: "StrategyExisted",
	}
	ErrInvalidUnmintAmount = &customErrorDef{
		code: 6010,
		msg:  "Invalid unmint amount",
		name: "InvalidUnmintAmount",
	}
	ErrInvalidAccountsForStrategy = &customErrorDef{
		code: 6011,
		msg:  "Invalid accounts for strategy",
		name: "InvalidAccountsForStrategy",
	}
	ErrInvalidBump = &customErrorDef{
		code: 6012,
		msg:  "Invalid bump",
		name: "InvalidBump",
	}
	ErrAmountMustGreaterThanZero = &customErrorDef{
		code: 6013,
		msg:  "Amount must be greater than 0",
		name: "AmountMustGreaterThanZero",
	}
	ErrMangoIsNotSupportedAnymore = &customErrorDef{
		code: 6014,
		msg:  "Mango is not supported anymore",
		name: "MangoIsNotSupportedAnymore",
	}
	ErrStrategyIsNotSupported = &customErrorDef{
		code: 6015,
		msg:  "Strategy is not supported",
		name: "StrategyIsNotSupported",
	}
	ErrPayAmountIsExeeced = &customErrorDef{
		code: 6016,
		msg:  "Pay amount is exceeded",
		name: "PayAmountIsExeeced",
	}
	ErrFeeVaultIsNotSet = &customErrorDef{
		code: 6017,
		msg:  "Fee vault is not set",
		name: "FeeVaultIsNotSet",
	}
	ErrLendingAssertionViolation = &customErrorDef{
		code: 6018,
		msg:  "deposit amount in lending is not matched",
		name: "LendingAssertionViolation",
	}
	ErrHaveMoneyInLending = &customErrorDef{
		code: 6019,
		msg:  "Cannot remove strategy becase we have some in lending",
		name: "HaveMoneyInLending",
	}
	Errors = map[int]CustomError{
		6000: ErrVaultIsDisabled,
		6001: ErrExceededSlippage,
		6002: ErrStrategyIsNotExisted,
		6003: ErrUnAuthorized,
		6004: ErrMathOverflow,
		6005: ErrProtocolIsNotSupported,
		6006: ErrUnMatchReserve,
		6007: ErrInvalidLockedProfitDegradation,
		6008: ErrMaxStrategyReached,
		6009: ErrStrategyExisted,
		6010: ErrInvalidUnmintAmount,
		6011: ErrInvalidAccountsForStrategy,
		6012: ErrInvalidBump,
		6013: ErrAmountMustGreaterThanZero,
		6014: ErrMangoIsNotSupportedAnymore,
		6015: ErrStrategyIsNotSupported,
		6016: ErrPayAmountIsExeeced,
		6017: ErrFeeVaultIsNotSet,
		6018: ErrLendingAssertionViolation,
		6019: ErrHaveMoneyInLending,
	}
)

type CustomError interface {
	Code() int
	Name() string
	Error() string
}

type customErrorDef struct {
	code int
	name string
	msg  string
}

func (e *customErrorDef) Code() int {
	return e.code
}

func (e *customErrorDef) Name() string {
	return e.name
}

func (e *customErrorDef) Error() string {
	return fmt.Sprintf("%s(%d): %s", e.name, e.code, e.msg)
}

func DecodeCustomError(rpcErr error) (err error, ok bool) {
	if errCode, o := decodeErrorCode(rpcErr); o {
		if customErr, o := Errors[errCode]; o {
			err = customErr
			ok = true
			return
		}
	}
	return
}

func decodeErrorCode(rpcErr error) (errorCode int, ok bool) {
	var jErr *ag_jsonrpc.RPCError
	if errors.As(rpcErr, &jErr) && jErr.Data != nil {
		if root, o := jErr.Data.(map[string]interface{}); o {
			if rootErr, o := root["err"].(map[string]interface{}); o {
				if rootErrInstructionError, o := rootErr["InstructionError"]; o {
					if rootErrInstructionErrorItems, o := rootErrInstructionError.([]interface{}); o {
						if len(rootErrInstructionErrorItems) == 2 {
							if v, o := rootErrInstructionErrorItems[1].(map[string]interface{}); o {
								if v2, o := v["Custom"].(json.Number); o {
									if code, err := v2.Int64(); err == nil {
										ok = true
										errorCode = int(code)
									}
								} else if v2, o := v["Custom"].(float64); o {
									ok = true
									errorCode = int(v2)
								}
							}
						}
					}
				}
			}
		}
	}
	return
}
