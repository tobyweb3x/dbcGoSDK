// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package dynamic_vault

import (
	"encoding/base64"
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
	ag_rpc "github.com/gagliardetto/solana-go/rpc"
	ag_base58 "github.com/mr-tron/base58"
	"reflect"
	"strings"
)

type AddLiquidityEventData struct {
	LpMintAmount uint64
	TokenAmount  uint64
}

var AddLiquidityEventDataDiscriminator = [8]byte{31, 94, 125, 90, 227, 52, 61, 186}

func (obj AddLiquidityEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(AddLiquidityEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `LpMintAmount` param:
	err = encoder.Encode(obj.LpMintAmount)
	if err != nil {
		return err
	}
	// Serialize `TokenAmount` param:
	err = encoder.Encode(obj.TokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *AddLiquidityEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(AddLiquidityEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[31 94 125 90 227 52 61 186]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `LpMintAmount`:
	err = decoder.Decode(&obj.LpMintAmount)
	if err != nil {
		return err
	}
	// Deserialize `TokenAmount`:
	err = decoder.Decode(&obj.TokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*AddLiquidityEventData) isEventData() {}
func (obj *AddLiquidityEventData) Self() any {
	return obj
}

type RemoveLiquidityEventData struct {
	LpUnmintAmount uint64
	TokenAmount    uint64
}

var RemoveLiquidityEventDataDiscriminator = [8]byte{116, 244, 97, 232, 103, 31, 152, 58}

func (obj RemoveLiquidityEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(RemoveLiquidityEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `LpUnmintAmount` param:
	err = encoder.Encode(obj.LpUnmintAmount)
	if err != nil {
		return err
	}
	// Serialize `TokenAmount` param:
	err = encoder.Encode(obj.TokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *RemoveLiquidityEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(RemoveLiquidityEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[116 244 97 232 103 31 152 58]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `LpUnmintAmount`:
	err = decoder.Decode(&obj.LpUnmintAmount)
	if err != nil {
		return err
	}
	// Deserialize `TokenAmount`:
	err = decoder.Decode(&obj.TokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*RemoveLiquidityEventData) isEventData() {}
func (obj *RemoveLiquidityEventData) Self() any {
	return obj
}

type StrategyDepositEventData struct {
	StrategyType StrategyType
	TokenAmount  uint64
}

var StrategyDepositEventDataDiscriminator = [8]byte{205, 53, 91, 239, 34, 136, 73, 47}

func (obj StrategyDepositEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(StrategyDepositEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `StrategyType` param:
	err = encoder.Encode(obj.StrategyType)
	if err != nil {
		return err
	}
	// Serialize `TokenAmount` param:
	err = encoder.Encode(obj.TokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *StrategyDepositEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(StrategyDepositEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[205 53 91 239 34 136 73 47]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `StrategyType`:
	err = decoder.Decode(&obj.StrategyType)
	if err != nil {
		return err
	}
	// Deserialize `TokenAmount`:
	err = decoder.Decode(&obj.TokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*StrategyDepositEventData) isEventData() {}
func (obj *StrategyDepositEventData) Self() any {
	return obj
}

type StrategyWithdrawEventData struct {
	StrategyType         StrategyType
	CollateralAmount     uint64
	EstimatedTokenAmount uint64
}

var StrategyWithdrawEventDataDiscriminator = [8]byte{120, 76, 208, 95, 221, 210, 229, 189}

func (obj StrategyWithdrawEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(StrategyWithdrawEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `StrategyType` param:
	err = encoder.Encode(obj.StrategyType)
	if err != nil {
		return err
	}
	// Serialize `CollateralAmount` param:
	err = encoder.Encode(obj.CollateralAmount)
	if err != nil {
		return err
	}
	// Serialize `EstimatedTokenAmount` param:
	err = encoder.Encode(obj.EstimatedTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *StrategyWithdrawEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(StrategyWithdrawEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[120 76 208 95 221 210 229 189]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `StrategyType`:
	err = decoder.Decode(&obj.StrategyType)
	if err != nil {
		return err
	}
	// Deserialize `CollateralAmount`:
	err = decoder.Decode(&obj.CollateralAmount)
	if err != nil {
		return err
	}
	// Deserialize `EstimatedTokenAmount`:
	err = decoder.Decode(&obj.EstimatedTokenAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*StrategyWithdrawEventData) isEventData() {}
func (obj *StrategyWithdrawEventData) Self() any {
	return obj
}

type ClaimRewardEventData struct {
	StrategyType StrategyType
	TokenAmount  uint64
	MintAccount  ag_solanago.PublicKey
}

var ClaimRewardEventDataDiscriminator = [8]byte{148, 116, 134, 204, 22, 171, 85, 95}

func (obj ClaimRewardEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ClaimRewardEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `StrategyType` param:
	err = encoder.Encode(obj.StrategyType)
	if err != nil {
		return err
	}
	// Serialize `TokenAmount` param:
	err = encoder.Encode(obj.TokenAmount)
	if err != nil {
		return err
	}
	// Serialize `MintAccount` param:
	err = encoder.Encode(obj.MintAccount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ClaimRewardEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ClaimRewardEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[148 116 134 204 22 171 85 95]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `StrategyType`:
	err = decoder.Decode(&obj.StrategyType)
	if err != nil {
		return err
	}
	// Deserialize `TokenAmount`:
	err = decoder.Decode(&obj.TokenAmount)
	if err != nil {
		return err
	}
	// Deserialize `MintAccount`:
	err = decoder.Decode(&obj.MintAccount)
	if err != nil {
		return err
	}
	return nil
}

func (*ClaimRewardEventData) isEventData() {}
func (obj *ClaimRewardEventData) Self() any {
	return obj
}

type PerformanceFeeEventData struct {
	LpMintMore uint64
}

var PerformanceFeeEventDataDiscriminator = [8]byte{28, 70, 231, 223, 81, 109, 239, 167}

func (obj PerformanceFeeEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(PerformanceFeeEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `LpMintMore` param:
	err = encoder.Encode(obj.LpMintMore)
	if err != nil {
		return err
	}
	return nil
}

func (obj *PerformanceFeeEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(PerformanceFeeEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[28 70 231 223 81 109 239 167]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `LpMintMore`:
	err = decoder.Decode(&obj.LpMintMore)
	if err != nil {
		return err
	}
	return nil
}

func (*PerformanceFeeEventData) isEventData() {}
func (obj *PerformanceFeeEventData) Self() any {
	return obj
}

type ReportLossEventData struct {
	Strategy ag_solanago.PublicKey
	Loss     uint64
}

var ReportLossEventDataDiscriminator = [8]byte{154, 36, 158, 196, 32, 163, 123, 126}

func (obj ReportLossEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(ReportLossEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `Strategy` param:
	err = encoder.Encode(obj.Strategy)
	if err != nil {
		return err
	}
	// Serialize `Loss` param:
	err = encoder.Encode(obj.Loss)
	if err != nil {
		return err
	}
	return nil
}

func (obj *ReportLossEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(ReportLossEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[154 36 158 196 32 163 123 126]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `Strategy`:
	err = decoder.Decode(&obj.Strategy)
	if err != nil {
		return err
	}
	// Deserialize `Loss`:
	err = decoder.Decode(&obj.Loss)
	if err != nil {
		return err
	}
	return nil
}

func (*ReportLossEventData) isEventData() {}
func (obj *ReportLossEventData) Self() any {
	return obj
}

type TotalAmountEventData struct {
	TotalAmount uint64
}

var TotalAmountEventDataDiscriminator = [8]byte{92, 200, 122, 145, 211, 203, 49, 205}

func (obj TotalAmountEventData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Write account discriminator:
	err = encoder.WriteBytes(TotalAmountEventDataDiscriminator[:], false)
	if err != nil {
		return err
	}
	// Serialize `TotalAmount` param:
	err = encoder.Encode(obj.TotalAmount)
	if err != nil {
		return err
	}
	return nil
}

func (obj *TotalAmountEventData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Read and check account discriminator:
	{
		discriminator, err := decoder.ReadTypeID()
		if err != nil {
			return err
		}
		if !discriminator.Equal(TotalAmountEventDataDiscriminator[:]) {
			return fmt.Errorf(
				"wrong discriminator: wanted %s, got %s",
				"[92 200 122 145 211 203 49 205]",
				fmt.Sprint(discriminator[:]))
		}
	}
	// Deserialize `TotalAmount`:
	err = decoder.Decode(&obj.TotalAmount)
	if err != nil {
		return err
	}
	return nil
}

func (*TotalAmountEventData) isEventData() {}
func (obj *TotalAmountEventData) Self() any {
	return obj
}

var eventTypes = map[[8]byte]reflect.Type{
	AddLiquidityEventDataDiscriminator:     reflect.TypeOf(AddLiquidityEventData{}),
	ClaimRewardEventDataDiscriminator:      reflect.TypeOf(ClaimRewardEventData{}),
	PerformanceFeeEventDataDiscriminator:   reflect.TypeOf(PerformanceFeeEventData{}),
	RemoveLiquidityEventDataDiscriminator:  reflect.TypeOf(RemoveLiquidityEventData{}),
	ReportLossEventDataDiscriminator:       reflect.TypeOf(ReportLossEventData{}),
	StrategyDepositEventDataDiscriminator:  reflect.TypeOf(StrategyDepositEventData{}),
	StrategyWithdrawEventDataDiscriminator: reflect.TypeOf(StrategyWithdrawEventData{}),
	TotalAmountEventDataDiscriminator:      reflect.TypeOf(TotalAmountEventData{}),
}
var eventNames = map[[8]byte]string{
	AddLiquidityEventDataDiscriminator:     "AddLiquidity",
	ClaimRewardEventDataDiscriminator:      "ClaimReward",
	PerformanceFeeEventDataDiscriminator:   "PerformanceFee",
	RemoveLiquidityEventDataDiscriminator:  "RemoveLiquidity",
	ReportLossEventDataDiscriminator:       "ReportLoss",
	StrategyDepositEventDataDiscriminator:  "StrategyDeposit",
	StrategyWithdrawEventDataDiscriminator: "StrategyWithdraw",
	TotalAmountEventDataDiscriminator:      "TotalAmount",
}
var (
	_ fmt.Formatter = nil
)
var (
	_ *ag_solanago.Transaction = nil
)
var (
	_ *strings.Builder = nil
)
var (
	_ *base64.Encoding = nil
)
var (
	_ *ag_binary.Decoder = nil
)
var (
	_ *ag_rpc.GetTransactionResult = nil
)
var (
	_ *ag_base58.Alphabet = nil
)

type Event struct {
	Name string
	Data EventData
}

type EventData interface {
	UnmarshalWithDecoder(decoder *ag_binary.Decoder) error
	isEventData()
	Self() any
}

const eventLogPrefix = "Program data: "

func DecodeEvents(txData *ag_rpc.GetTransactionResult, targetProgramId ag_solanago.PublicKey, getAddressTables func(altAddresses []ag_solanago.PublicKey) (tables map[ag_solanago.PublicKey]ag_solanago.PublicKeySlice, err error)) (evts []*Event, err error) {
	var tx *ag_solanago.Transaction
	if tx, err = txData.Transaction.GetTransaction(); err != nil {
		return
	}

	altAddresses := make([]ag_solanago.PublicKey, len(tx.Message.AddressTableLookups))
	for i, alt := range tx.Message.AddressTableLookups {
		altAddresses[i] = alt.AccountKey
	}
	if len(altAddresses) > 0 {
		var tables map[ag_solanago.PublicKey]ag_solanago.PublicKeySlice
		if tables, err = getAddressTables(altAddresses); err != nil {
			return
		}
		tx.Message.SetAddressTables(tables)
		if err = tx.Message.ResolveLookups(); err != nil {
			return
		}
	}

	var base64Binaries [][]byte
	logMessageEventBinaries, err := decodeEventsFromLogMessage(txData.Meta.LogMessages)
	if err != nil {
		return
	}

	emitedCPIEventBinaries, err := decodeEventsFromEmitCPI(txData.Meta.InnerInstructions, tx.Message.AccountKeys, targetProgramId)
	if err != nil {
		return
	}

	base64Binaries = append(base64Binaries, logMessageEventBinaries...)
	base64Binaries = append(base64Binaries, emitedCPIEventBinaries...)
	evts, err = parseEvents(base64Binaries)
	return
}

func decodeEventsFromLogMessage(logMessages []string) (eventBinaries [][]byte, err error) {
	for _, log := range logMessages {
		if strings.HasPrefix(log, eventLogPrefix) {
			eventBase64 := log[len(eventLogPrefix):]

			var eventBinary []byte
			if eventBinary, err = base64.StdEncoding.DecodeString(eventBase64); err != nil {
				err = fmt.Errorf("failed to decode logMessage event: %s", eventBase64)
				return
			}
			eventBinaries = append(eventBinaries, eventBinary)
		}
	}
	return
}

func decodeEventsFromEmitCPI(InnerInstructions []ag_rpc.InnerInstruction, accountKeys ag_solanago.PublicKeySlice, targetProgramId ag_solanago.PublicKey) (eventBinaries [][]byte, err error) {
	for _, parsedIx := range InnerInstructions {
		for _, ix := range parsedIx.Instructions {
			if accountKeys[ix.ProgramIDIndex] != targetProgramId {
				continue
			}

			var ixData []byte
			if ixData, err = ag_base58.Decode(ix.Data.String()); err != nil {
				return
			}
			if len(ixData) < 8 {
				continue
			}

			eventBase64 := base64.StdEncoding.EncodeToString(ixData[8:])
			var eventBinary []byte
			if eventBinary, err = base64.StdEncoding.DecodeString(eventBase64); err != nil {
				return
			}
			eventBinaries = append(eventBinaries, eventBinary)
		}
	}
	return
}

func parseEvents(base64Binaries [][]byte) (evts []*Event, err error) {
	decoder := ag_binary.NewDecoderWithEncoding(nil, ag_binary.EncodingBorsh)

	for _, eventBinary := range base64Binaries {
		if len(eventBinary) < 8 {
			continue
		}
		eventDiscriminator := ag_binary.TypeID(eventBinary[:8])
		if eventType, ok := eventTypes[eventDiscriminator]; ok {
			eventData := reflect.New(eventType).Interface().(EventData)
			decoder.Reset(eventBinary)
			if err = eventData.UnmarshalWithDecoder(decoder); err != nil {
				err = fmt.Errorf("failed to unmarshal event %s: %w", eventType.String(), err)
				return
			}
			evts = append(evts, &Event{
				Name: eventNames[eventDiscriminator],
				Data: eventData,
			})
		}
	}
	return
}
